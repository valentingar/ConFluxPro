% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/discretize_depth.R
\name{discretize_depth}
\alias{discretize_depth}
\title{discretize_depth}
\usage{
discretize_depth(df, param, method, depth_target, control, id_cols)
}
\arguments{
\item{df}{(dataframe) The dataframe containing the parameters to be interpolated, as well as the columns "depth", upper" and lower.}

\item{param}{(character vector) The column names name of the parameters to be interpolated.}

\item{method}{(character vector) a character (-vector) specifying the methods to be used for interpolation. Must be in the same order as param. One of
"linear" = linear interpolation.
"boundary" = mapping values to any depth within the boundarys. Suited for discrete variables.
"exp" = exponential fit
"spline_lin" = fits a linear spline. similar to linear interpolation but}

\item{depth_target}{(numeric vector or data frame) specifying the format of the depths to be interpolated. Must include n+1 depths for n target depth steps. If it is different per Plot, enter a data.frame instead with the columns: Plot and depth.}

\item{id_cols}{(character vector) = The names of the columns to be grouped by, i.e. uniqueley identifying one profile (usually 'Plot' and 'Date').}

\item{boundary_nearest}{(logical vector) = TRUE/FALSE if it is TRUE then for target depth steps (partially) outside of the parameter boundaries, the neigherst neighbour is returned, else returns NA. Default is FA}

\item{int_depth}{(numeric vector)  = value between 0 and 1 for 1 = interpolation takes the top of each depth step, 0.5 = middle and 0= bottom. Default = 0.5}
}
\value{
dataframe with the columns upper and lower derived from depth_target, depth being the middle of each depth step, as well as the interpolated and discretised parameters.
}
\description{
This function helps to interpolate and discretize the data in soiltemp and soilwater to match a set final
form for the soilphys dataframe. The idea is that the profile is discretized into set depth steps (see depth_target),
each specifying a layer with an upper and lower boundary. So that for example one depth step is from top of the humus layer to +5 cm, the next from 5 to 0 cm and so on.
The format of this final dataframe is specified in "depth_target", where a numeric vector of the boundrys is given. (e.g. c(6,3,0,-5,-10) resulting in 4 depth steps)
There are different interpolation methods implemented, which might be more practical for different parameters.

 A linear interpolation is possible for more or less contiuous parameters, (e.g. top soil temperature)
 A boundry interpolation is similar to a neirest neighbour interpolation and uses the values set in the upper and lower variables
 to map the parameter to any depth within these limits.
 The control parameter "tie_up" determines here wether the upper or lower boundry is included. It is T by default.
 An exponential interpolation fits an exponential function to the parameter agains depth and predicts values accordingly.
 a linear spline interpolation fits a linear spline model to the data with knots defined in the controlvariable "spline_knots".

Data given to discretize_depth must always represent one profile, i.e. must be grouped by Plot (& Date for temporal data).
If only one value is given for method, boundary_nearest, int_depth the same is applied to all parameters given in "param"
}
