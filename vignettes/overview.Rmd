---
title: "overview"
author: Valentin Gartiser
date: '2022-04-29'
output: 
  rmarkdown::html_vignette:
    number_sections: true 
    fig_width: 7
    fig_height: 4
    toc: true
    toc_depth: 3
    
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
<style>
    img {
        border: 0;
    }
</style>

<img src="../inst/logo.svg" width="300" height="300" style ="float:right"/>

# Introduction

Hello and welcome to ConFluxPro - a toolkit for soil gas analysis.

This package implements the **Flux-Gradient Method (FGM)** for the calculation of
gas fluxes from concentration profiles. It provides a range of functions that cover
the complete process from raw data to modeling fluxes and beyond. A framework of S3 classes 
and methods aim to make the process as straightforward as possible while keeping 
the control of the specific model in the hands of the user.

This vignette provides an overview over the package structure, including the 
most important functions and workflows. Further vignettes will introduce the
different models, functions and processes in more detail. 

# Package structure

The following graph gives an overview over the most important functions within
ConFluxPro. There are two main data objects that are required for ConFluxPro models
**gasdata** and **soilphys**. The former contains information on *gas concentration* 
profiles, the latter corresponding information on soil physical parameters and,
most importantly, *diffusivity*. The model structure is defined in **layers_map**, 
where *layers* are defined for which different parameters are set. All data comes 
together in a single object with **cfp_dat()**. Here, the different data sources
are checked and prepared for modelling.

Models include a traditional FGM approach in **fg_flux()**, as well as an inverse
approach in **pro_flux()**. From every model result, the soil *efflux* and other 
parameters can be extracted. Further functions help improve and analyse the models.

This framework is designed to be as modular as possible, so that any kind of 
approach can be implemented. Each function has documentation attached (`?my_function`)
to help setting up the data and the models. In the next chapter a typical 
workflow will be presented using synthetic datasets that are included in the package.

```{r, echo = FALSE}
DiagrammeR::grViz(diagram = "digraph flowchart {
graph [layout = dot, rankdir = LR]


  node [style = filled color = white shape = rectangle]
  node [fillcolor = BlueViolet fontcolor = white]
  a [label = 'gasdata']
  b [label = 'soilphys']
  c [label = 'layers_map']
  h [label = 'cfp_dat']
  m [label = 'cfp_fgres']
  n [label = 'cfp_pfres']
  o [label = 'EFFLUX']
  p [label = 'PRODUCTION']
  s [label = 'cfp_altres']
  
  
  node [fillcolor = orange shape = oval fontcolor = black]
  d [label = 'cfp_dat()']
  e [label = 'cfp_gasdata()']
  f [label = 'cfp_soilphys()']
  g [label = 'cfp_layers_map()']
  i [label = 'fg_flux()']
  j [label = 'pro_flux()']
  k [label = 'efflux()']
  l [label = 'production()']
  q [label = 'run_map()']
  r [label = 'alternate()']
  
  a -> {e}
  b -> {f}
  c -> {g}
  {e f g} -> d
  d -> h
  h -> {i j}
  i -> m
  j -> n
  {m n} -> {k l r}
  k -> o
  l -> p
  q -> r
  r -> s
  
   subgraph clusterMain {
   graph [rankdir = TB]
   node [style = filled color = white shape = rectangle]
  node [fillcolor = BlueViolet fontcolor = white]
  aaa [label = 'objects']


  node [fillcolor = orange shape = oval fontcolor = black]
  bbb [label = 'functions()']
   
}
  
}
 
  ")
```

# General workflow
## data preparation

There are two datasets required for a ConFluxPro flux model. One giving information
on the gas concentration profiles (`gasdata`) and one on the physical properties and
diffusivity of the soil (`soilphys`). ConFluxPro ships a synthetic example dataset
to illustrate the form of the datasets required. To access the datasets use the
`data()` function:

```{r}
library(ConFluxPro)

data(gasdata)
data(soilphys)
```

### gasdata
`gasdata` has three important columns: `depth` gives the depth of the data entry in cm,
`x_ppm` the concentration in ppm and `gas` the type of the gas as a character string.
Any further columns may identify each profile. For the example datasets, these 
include `site` as well as `Date`:
```{r}
head(gasdata)
```
A profile is a single vertical snapshot of a soil column. Each profile will result in a 
single efflux to / from the atmosphere. Parameters that characterise each profile
are `id_cols` in ConFluxPro. To set up gasdata for a model, we run `cfp_gasdata()`.
Here, we have to define the `id_cols` of the dataset. That is used to verify that
the dataset is ready, i.e. that there are no incomplete profiles. Otherwise, 
an error is returned.
```{r}
gasdata <- cfp_gasdata(gasdata, id_cols = c("site", "Date"))
```

### soilphys
The next part is to prepare the `soilphys` object. Each profile is separated 
into discrete steps for which soil physical parameters are defined. Each step
has an upper and lower boundary that cover the complete depth of the profile
without overlapping and gaps. In ConFluxPro, this is called *upper/lower consistency*. 
Each step is considered homogeneous, which means that any parameter (e.g. total pore space) 
is assumed constant within the step. For flux modeling, `soilphys` needs to have
the following columns: `upper` and `lower` boundaries of each step in cm, the 
apparent diffusion coefficient `DS` in m^2^ s^-1^ and `gas`. To get to this place,
there are different functions that help set up such a dataset from different sources
(see `discretize_depth()` and `complete_soilphys()`), the example dataset is already
in shape, so that we can run `cfp_soilphys()` directly. Again, any `id_cols` need to 
be defined. 
```{r}
head(soilphys)

soilphys <- cfp_soilphys(soilphys, id_cols = c("site", "Date"))
```
`cfp_soilphys()` checks for upper/lower consistency and other indicators
of data integrety. Should your data fail here (and `cfp_soilphys()` return an error), 
make sure that you have only a single entry per step and profile (idfentified by 
the `id_cols` provided) and that your steps are not overlapping and without gaps.

### layers_map
The final puzzle-piece for a model-ready dataset is `layers_map`. Here, any *layers*
are defined, for which fluxes should be calculated independently or, in the case
of the inverse approach, production rates should be optimised. This means, that
different `layers_map` can be defined and tried out. Layers are defined by an `upper` 
and `lower` boundary in cm. For now, we will consider two layers per site: One in the 
Humus layer (here: depth > 0 cm) and one in the mineral soil (depth < 0 cm):
```{r, message=FALSE, eval=TRUE}
library(dplyr)

```

```{r}
  layers_map <- 
    soilphys %>% # use limits of soilphys per site
    select(upper,site) %>%
    distinct() %>%
    group_by(site) %>%
    slice_max(upper) %>%
    summarise(upper = c(upper,0),
              lower = c(0,-100)) 

  layers_map
```
Using `cfp_layers_map()` the data is checked for integrity and further
model-specific parameters defined.

```{r}
layers_map <-
  cfp_layers_map(
    layers_map,
    gas = "CO2",
    id_cols = "site",
    layer_couple = 0,  # only for pro_flux()
    lowlim = 0,        #   
    highlim = 1000     #
  )
```

### Binding it all together: cfp_dat()

The centrepiece of every ConFluxPro model is a `cfp_dat` object. `cfp_dat()`
takes a `cfp_gasdata`, `cfp_soilphys` and `cfp_layers_map` object and connects
the different datasets together. For all combinations of `id_cols` within the
datasets, a single `prof_id` is defined and each profile checked for integrity.
This means, that for each profile, the three datasets need to match: 
The lowest and highest `depth` of `gasdata` must exactly match the highest and lowest
`upper` and `lower` boundary of `soilphys` and `layers_map`. Each profile must be
complete, meaning that all three corresponding datasets must be matched uniquely per
profile. This does not mean, that the `id_cols` must be the same for the datasets, only
that they must be mappable to the other datasets. E.g. notice, that `layers_map` is
missing the `id_cols` `"Date"`, which is no problem, because it can still be matched using
`"site"`. If everything is ready, run `cfp_dat()` to join the datasets together. If the 
data is not yet ready, the function will giv information about missing / not matching data.
```{r}
my_dat <- cfp_dat(gasdata,
                  soilphys,
                  layers_map)
```

A `cfp_dat` object is essentially a list of the original datasets and a fourth `data.frame` that has information on each single profile defined by the `Ã¬d_cols`.
This means, that all the elements can be accessed using the normal `$` operator:
```{r}
my_dat$layers_map
```
In the `profiles` `data.frame`, each row corresponds to a single profile with the
corresponding `id_cols`, as well as ids, mapping the profile in the other datasets:
`sp_id` for `soilphys`, `gd_id` for `gasdata` and `group_id` for `layers_map`.

When printing a `cfp_dat` object, the most relevant information is displayed:
```{r}
my_dat
```

Different dplyr-like methods are implemented. Model data can be subsampled using
`filter()`. Any columns of the `profiles` data.frame can be used for filtering
(This ensures that only complete profiles are filtered).
```{r}
my_dat %>%
  filter(site == "site_a")

my_dat %>% 
  filter(Date < "2021-04-01")


my_dat %>% 
  filter(prof_id %in% c(4, 6, 23))
```

## Models
### Flux-Gradient-Method FGM with fg_flux()
The 'classic' approach of calculating fluxes from concentration profiles is to estimate the gradient of a gas along its direction of diffusion and use Fick's law:
$$
F = - D_s \cdot \frac{dc}{dz}
$$
This is implemented in ConFluxPro in the `fg_flux()` function. Within each layer defined in `layers_map`, the gradient is estimated. The corresponding diffusion coefficient is the harmonic mean of the apparent diffusion coefficient within this layer, weighed by the height of each step within `soilphys`. Different methods are implemented to estimate the gradient, e.g. a linear spline method, local linear regression and so on. These can be defined in the function call. For now, let's use a linear spline function to estimate the gradients within the humus and mineral soil layer we defined beforehand:
```{r}
FLUX <-
my_dat %>%
  fg_flux(gases = "CO2", 
          modes = "LS", # use linear spline to estimate gradient 
          param = c("c_air", "DS"), # soilphys parameters averaged per layer
          funs = c("arith", "harm") # averaging function corresponding to param
          )

```

The resulting object stores all the input datasets and parameters and the flux results are only added to the list of data.frames and can thus be accessed by running `FLUX$FLUX`. The advantage of keeping the input parameters is twofold: a) you always can check the parameters that produced the model result and b) it makes it easy to tweak things and try again. This also means that we can 
rerun the model with a simple command:
```{r}
fg_flux(FLUX) # all the information is already there
```

Let's visualise the results using ggplot:

```{r, message = FALSE}
library(ggplot2)
```

```{r}
FLUX$FLUX %>%
  left_join(FLUX$profiles) %>% # here is the info about the Date and site we need
  ggplot(aes(x = Date, y = flux, col = factor(layer)))+
  geom_line()+
  facet_grid(rows = vars(site))+
  theme(legend.position = 'bottom')
```
The layer numbering always starts at the bottom, so that 1 (red) denotes the mineral soil and 2 (blue) the humus layer. 

### Inverse Flux moddeling pro_flux()
A different way t

### Extract and calculate the efflux()
