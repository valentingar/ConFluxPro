---
title: "gradient-flux-workflow"
author: "Valentin Gartiser"
date: "2021-08-21"
output: 
  rmarkdown::html_vignette:
    number_sections: true 
    fig_width: 7
    fig_height: 4
    
vignette: >
  %\VignetteIndexEntry{gradient-flux-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
Hello and welcome to ConFluxPro - a toolkit for soil gas analysis. The goal of this package was to implement the gradient-flux approach for modelling soil gas fluxes based on concentration measurements. A good starting point to get an idea of the setup and ideas behind this method is our paper Maier et al. (2020).

This vignette is a starting point to introduce the general structure of the package and show the workflow of the gradient-flux approach. We will use the (synthetic) example data that is included in the package. We will format the data into the structure we need for the model, calculate necessary parameters and finally calculate the fluxes using different approaches.

# Data preparation
## Gas concentration data
### Structure
With the next few lines of code, we will import different datasets and join them together to generate the two most important data.frames needed to run the model. The first part is the `gasdata` dataset. This is quite straight-forward a `data.frame`, where each row is an observation of a concentration of a specific gas at a specific depth. The concentration (`NRESULT_ppm`) must be in ppm, `depth` in cm and `gas` a character that must match the gases supported by `calculate_flux()`. We can have a look at the structure in the example data provided by loading it and looking at the first few rows.

```{r setup, warning = F, message=FALSE}
library(ConFluxPro)

gasdata <- ConFluxPro::gasdata
head(gasdata)
```

As can be seen, the dataset already follows the form described above. Additional columns give further information. `site` shows that some of the data was 'collected' at "site_a", while some is from "site_b". The `Date`column has the sampling date and `repetition` shows that we have multiple observations per depth that are here specified. All the data are CO2 concentrations. Let's take a closer look at the data by creating a few plots:
```{r conc_time, warning = F, message=FALSE}
library(ggplot2)
library(dplyr)
library(splines)

gasdata %>% 
  ggplot(aes(x=Date,y=NRESULT_ppm,col = factor(depth)))+
  stat_summary(geom = "line",
               fun = "mean")+
  facet_wrap(~site)+
  ggtitle("time series concentration")

gasdata %>%
  ggplot(aes(x=depth,y=NRESULT_ppm,col = season(Date)))+
  stat_smooth(geom = "line",
              method = "lm",
              formula = y~bs(x,knots = c(0,-10,-20),degree = 1))+
  geom_point()+
  coord_flip()+
  facet_wrap(~site)+
  ggtitle("mean seasonal profiles")
 
```


The data follows a typical seasonal development for soil CO2 concentrations with highest concentrations in summer and further down in the profile. As we can see, the profiles look very 'good' already and, because the dataset was created synthetically, shows no outliers or systematic errors. This data.frame is, as is, ready for the model. However, real-world data seldom looks this way - random noise, outliers or systematic errors stemming from the measurements themselves can significantly affect the results. For this reason, different functions are added to help clean up the data.

### Gasdata: Correction functions
Three different functions are implemented to help to fix different problems with the gas dataset: `balance_correction()`, `series_cleaner`, `offset_correction`.

#### balance_correction()
`balance_correction()` is useful for gas data that are measured using gas samples and quantitive analysis (e.g. via GC) of the complete samples. If all the relevant gases of the sample are quantified, the sum of their concentration should equal 1. If the sum is less than one, not the complete sample was measured. This is a common problem when samples are collected passively via diffusive exchange of helium-filled gas vials. This correction is especially necessary if the gases to be moddeled are not only present in trace amounts. For instance, small relative deviations in the absolute concentration of oxygen can be of similar magnitude as the gradients within the soil. This can lead to smaller fitted gradients and, therfore, underestimated fluxes.

To apply the correction, `SAMPLE_NO` must be supplied in `gasdata`, which is a unique identifier (e.g. an integer) for each sample, grouping together the different gases of each sample. In the function call, the gases used for summation (`gases`) must be supplied. For easy filtering of incomplete samples, "Obligatory" gases (`gases_ob`) that must be non-NA for the correction to work properly can be defined as well. If any of `gases_ob` are missing in the sample to be corrected, the sample is flagged and the concentrations not corrected. For all the `gases` provided, expected concentration (i.e. atmospheric concentration) `gases_std` must be provided to also correct incomplete samples. Below is an example how the function works for a very simple dataset of only one sample. However, the dataset can have any number of samples, provided `SAMPLE_NO` is given. An important aspect is, that the resulting dataset should be checked for integrity after the correction. For example duplicates may significantly disturb the result.

```{r}
# create example dataset
df <- data.frame(SAMPLE_NO = 1,
                 gas = c("N2","O2","Ar","CO2"),
                 NRESULT_ppm = c(0.78158,0.209,0.009,0.00042))
df$NRESULT_ppm <- df$NRESULT_ppm*1e6

# immitate 20 % mass difference
df$NRESULT_ppm <- 0.8*df$NRESULT_ppm

# show sum of all gases is different to 1
sum(df$NRESULT_ppm)/1e6

#apply balance correction
df_balcor <-
  balance_correction(df,
                     limits = c(0.6,1.2), # if sum is larger than/maller than limits, sample is flagged
                     gases = c("N2","O2","Ar","CO2"),
                     gases_std = c(0.78158,0.209,0.009,0.00042),
                     gases_ob = c("N2","O2"),
                     set_na = T #flagged samples are set NA
                     )


# show sum of all gases is 1
sum(df_balcor$NRESULT_ppm)/1e6

#show difference between original and new O2 concentration
df$NRESULT_ppm[df$gas == "O2"]
df_balcor$NRESULT_ppm[df_balcor$gas == "O2"]


```


#### series_cleaner()

TODO

#### offset_correction()

TODO

### soilphys

The `soilphys` dataset is the counterpart of the complete model. It contains all the necessary information of the physical properties of the soil, and especially diffusivity. For the calculation of gas fluxes, the specific diffusion coefficient `DS` must be known. It can be estimated from the air filled pore space `AFPS` and the normal diffusion coefficient of the specific gas in air `D0`, which is pressure and temperature dependent. Because different parameters that are needed for the calculation of the diffusion coefficient may come from different sources with different spatial resolutions, a function is provided to help discretise the different parameters to match a common spatial resolution (`discretize_depth()`). To calculate the diffusion coefficient from the necessary parameters, the function `complete_soilphys()` was implemented. Afterwards, the dataset can be checked for model readiness by applying `check_soilphys()`.

#### Discretisation of different data sources

In the following, datasets of soil water content `SWC`, soil total pore space `TPS` and fitting parameters of diffusion models `a` and `b`, temperature `Temp` and pressure `p` will be discretised to match a common depth resolution using the function `discretize_depth()`. The goal is to have a dataset, where each soil profile is divided into layers with no gaps in between and for each layer the different parameters are discretised.

We start by importing the different datasets. `soiltemp` are point observations of temperature, `soilwater` the (synthetic) result of a soil water model with distinct layers of soil water content, `soildiff` also has layers that represent the different soil horizons with total pore space and fitting parameters of diffusion models. 

```{r}
soilwater <- ConFluxPro::soilwater
soiltemp <- ConFluxPro::soiltemp
soildiff <- ConFluxPro::soildiff

```

Next, we will create the data.frame `dt`. This will define the layers for each distinct location. Each intersection between layers and the upper and lower bound of the profiles are provided in the column `depth`. This means, that for _n_ target layer _n+1_ depths must be provided. For simplicity, we will use the layers of `soilwater` as our target, however any discretisation could be possible, with some constraints discussed later. 

```{r, message=FALSE}
library(tidyr)
dt <- soilwater %>%
  select(upper,lower,site) %>%
  distinct() %>%
  pivot_longer(cols = c(upper,lower),
               names_to = "tmp",
               values_to = "depth") %>%
  select(site,depth) %>%
  distinct()
head(dt)
```

Now we can start discretising the other datasets. Because the target discretisation is the same as that of `soilwater`, no additional manipulation is needed here. Let's start with `soildiff`.
```{r}
soildiff
```

`soildiff` has distinct layers that are defined with an `upper` and `lower` boundary. These layers represent the horizons of the soil that are assumed homogenous. Hence, we will only map the discrete values of these layers to the new layers. For this, we will use the `boundary` method. Important is, that no new layer lays over the intersection of an old layer - otherwise this layer will have only NAs. The `id_cols` are added to identify each unique profile. Here, this is only the `site` column.

```{r}
soildiff_dis <- 
  soildiff %>%
  discretize_depth(param = c("TPS","a","b"), #list of the parameters from the source df to be discretised
                   method = "boundary", # list or single value of the method to be used
                   depth_target = dt, # the target discretisation
                   id_cols = "site" # the columns that, together, identify one profile uniquely 
                   )
soildiff_dis
```

A new data.frame was created with the mapped parameters, as well as the `upper` and `lower` bounds of each layer and its mean `depth`.

Next up is `soiltemp`. Instead of layers with discrete values, we have distinct point measurements at different depths. We will use the `linear` method for interpolation and discretisation. This will linearly interpolate between the point measurements and take the values at the middle of each depth. The syntax is very similar to before:
```{r}
soiltemp_dis <- 
  soiltemp %>%
  discretize_depth(param = "Temp",
                   method = "linear",
                   depth_target = dt,
                   id_cols =  c("site","Date") #Date variable added, because temperature is also time-dependent 
                   )
nrow(soiltemp)
nrow(soiltemp_dis)
head(soiltemp_dis)
```

As we can see, the new data.frame matches the structure of soilwater and soildiff with a unique temperature for each `layer`, `site` and `Date`. Hence, the data is now ready to be joined. 

```{r}
soilphys <- 
  soildiff_dis %>%
  left_join(soilwater) %>%
  left_join(soiltemp_dis)
```

We will assume a constant pressure for the whole dataset, however measurements could be easily added via a simple join or following the worklfow above. 
```{r}

soilphys$p <-1013 # in hPa
```

Now, the raw data is discretised and the soilphys dataset created, the calculation of diffusion coefficients can proceed. 
```{r}
head(soilphys)
```

### Calculation of diffusion coefficients

If soilphys was created properly, the calculation of diffusion coefficients is straightforward by running:

```{r}
soilphys_complete <-
  complete_soilphys(soilphys %>% mutate(Plot = "p"),
                    DSD0_formula = "a*AFPS^b",
                    gases = "CO2")
```

But let's untangle what's happening in the background. soilphys_complete will create the columns `AFPS`, `DSD0`,`D0`, `DS`, and `rho_air`. `AFPS` is the air filled pore space and is calculated as the difference bewtween the total pore space `TPS` and the soil water content `SWC`.

$AFPS = TPS - SWC$

`DSD0` is the diffusivity and is calculated using the formula provided in the function call `DSD0`. Here, the diffusion model fitting parameter `a` and `b` are used in an exponential model, however different formulas can be provided _in plain text_, i.e. no variables outside soilphys can be referenced. `D0` is the diffusion coefficient in air and is calculated following Massman (1998) as

$D_0 = a\cdot ((Temp+273.15) / 273.15)^b \cdot 1013/p$.

With Temp given in _°C_ and p in _hPa_. 

The specific diffusion coefficient `DS` is then calculated as the product of `DSD0` and `D0`: 

$D_S =D_S/D_0 \cdot D_0$

Because `D0` is different for different gases, for any gas provided as a character vector in `gases`, a different `D0` is calculated. This means that the resulting data.frame of `soilphys_complete()` has $m\cdot n_{gases}$ rows, if the input data.frame had _m_ rows. Keep this in mind if very large datasets are to be modelled and only calculate diffusion coefficients for the gases needed. 

Finally, the number density of air `rho_air` is calculated in mol m^-3^ as 

$\rho_{air} = 100*p/(8.314\cdot (Temp+ 273.15))$

Of course `DS` (e.g. from on site measurements) can also be added manually. However, it is recommended that `complete_soilphys()` is run nonetheless with a dummy `DSD0_formula` and the values overwritten afterwards to ensure that the structure of the dataframe is ready for the model. To check this, we can run 

```{r,eval=FALSE}
check_soilphys(soilphys_complete)
```

Now the `soilphys` dataset is ready to be used in flux calculation. 

# Flux Calculation

## General Approach

The gradient-flux approach is implemented in the function `calculate_flux()`. It takes the datasets `gasdata` and the (completed) `soilphys` as an input. The goal was to give the user a fast and simple to use way to try out different model approaches and parameterisations. The basic approach is that, for layers defined in the function call, gradients of concentration are calculated and a mean `DS`. Then the flux is calculated as follows:

$$
f = dc_{ppm}/dz \cdot rho_{air} \cdot D_S 
$$
The user needs to define layers for the calculation of fluxes. These are in the process assumed homogeneous, and the flux constant so that the equation above applies. How this should be done is described later.

Different approaches for calculating `dcdz_ppm` are implemented with the easiest being __LL__. This approach uses a simple linear regression fit within each layer to calculate the gradient. Another option is __LS__. Here, a linear spline is fit to the complete profile with the intersections of the layers as knots. For each layer the gradient is then calculated as the difference between the fitted upper and lower concentration. The approach __EF__ fits an exponential function and takes the gradient of it at the Atmosphere/Soil interface as the first derivative of the exponential function.

The other part of the calculate_flux is to average `DS` for the flux calculation from the `soilphys` dataset provided in the function call. Here, either harmonic (recommended) or arithmetic means are possible. In either case, the height of the layers that make up each flux layer is used as a weight.

## Examples 

First, we must define homogenous layers for both sites for which we assume the flux to be constant. For this, we create the `layers_map` data.frame that is different for both sites of the example dataset (because the Humus height is different). We can use the depths of the `gasdata` dataset as reference. For simplicity, we will only consider two different layers: the Humus and mineral soil layers.

```{r}
layers_map <-
  gasdata %>% select(site,depth) %>%
  distinct() %>%
  group_by(site) %>%
  slice_max(depth) %>% # get the humus height
  summarise(upper = c(depth,0), #add upper = 0 and lower = -100 for mineral soil layer
            lower = c(0,-100),
            layer = c("HU","M1")) %>%
  ungroup()
```

Now we are ready to calculate the flux:

```{r}
FLUX <-
  calculate_flux(gasdata = gasdata,
                 soilphys = soilphys_complete,
                 layers_map = layers_map,
                 gases = "CO2",
                 modes = c("LL","LS"),
                 param = c("DS","rho_air"),
                 funs = c("harm","arith"),
                 id_cols = c("site","Date"))
```


## Extrapolation 


